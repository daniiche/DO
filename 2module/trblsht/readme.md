## Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

напишите список операций, которые вы будете производить для остановки запроса пользователя
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

```
 Я использую abortTransaction
 
 Terminates the multi-document transaction and rolls back any data changes made by the operations within the transaction. That is, the transaction ends without saving any of the changes made by the operations in the transaction.
 
 {
  abortTransaction: 1,
  txnNumber: <long>,
  writeConcern: <document>,
  autocommit: false,
  comment: <any>
}
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

```
я установлю мониторинги
CONFIG SET watchdog-period 500

CONFIG SET latency-monitor-threshold 100

Посмотрю, нет ли зависшей транзакции, которая лочит таблицу через slowlog

Посмотрю место на диске, есть ли куда записывать.

Проверю правильность выставления портов и доступность сети.

проверю правильность доступов и прав на запись

Сравню время TTL и время на обработку транзакции/отклик сервера.
```

Upd доработка

```
Одно проедположить, что запись блокируется Редисом из за того,
Цикл удаления истёкших ключей не поспевает за темпом признания ключей устаревшими. 
Например, мы имеем стандартный конфигурационный файл с настройкой 
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP=20, что даёт темп в 200 ключей в секунду.

Если мы имеем ситуацию, когда много ключей истекают в каждый момент цикла и их доля
от выборки составляет более 25% - редис заблокирует операции для того, чтобы вернуть
долю истёкших ключей к показателю менее четверти от выборки.  

```

## Задача 3

Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

```
Возможно исчерпан лимит одновременных подключений - стоит сократить время сессий.

Если за один запрос нам нужно получить больше строк:
 should try increasing net_read_timeout from its default of 30 seconds to 60 seconds or longer, sufficient for the data transfer to complete.
 

```

## Задача 4

Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

postmaster invoked oom-killer

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

```
недостаточно оперативки

Проверил потреблоение процессом постгреса оперативки в рантайме и выделил больше / либо посмотрел на тяжелые запросы, что так нагружают систему
```

Upd доработка
```
Вы случае, если ситуация на проще острая, оперативной памяти выделить неоткуда, на сервере нет процессов, которые можно было бы завершить и мы считаем, что запросы работают в штатном режиме, 
То для процесса постгреса можно отрегулировать параметр oom_score_adj
Поставив в него отрицательное число, что уменьшит шансы процессу постгреса быть выбранным для остановки при нехватке памяти. 
rcctl set <i>servicename</i> oomprotect -100
```
